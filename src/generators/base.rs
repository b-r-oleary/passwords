extern crate rand;

use std::str::FromStr;

use rand::{ThreadRng, Rng};

pub static ASCII_LOWERCASE: &str = "abcdefghijklmnopqrstuvwxyz";
pub static ASCII_UPPERCASE: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
pub static DIGITS: &str = "0123456789";


/// A trait that is implemented by all objects that generate passwords.
pub trait PasswordGenerator {
    /// Generate a random password given a seed and random number generator.
    /// 
    /// # Arguments
    /// * `rng` - a random number generator
    /// * `seed` - an input string that the random number generator can act on.
    /// 
    fn generate_with_seed(&self, _rng: &mut ThreadRng, seed: String) -> String {
        seed
    }

    /// Generate a random password.
    /// 
    /// Calls `generate_with_seed` with a new random number generator and an
    /// empty seed string
    /// 
    fn generate(&self) -> String {
        let mut rng = rand::thread_rng();
        self.generate_with_seed(&mut rng, String::new())
    }

    /// Create a `ChainedGenerator` by pipelining this `PasswordGenerator` with
    /// another one.
    fn pipe<'a, T>(self, other: T) -> ChainedGenerator<'a>
        where
            Self: Sized + 'a,
            T: PasswordGenerator + Sized + 'a
    {
        ChainedGenerator { 
            first: Box::new(self),
            second: Box::new(other),
        }
    }

    /// Create a `PasswordIterator` from a `PasswordGenerator` which will generate
    /// an infinite sequence of random passwords when used as an iterator.
    fn iterator<'a>(self) -> PasswordIterator<'a>
        where Self: Sized + 'a
    {
        let rng = rand::thread_rng();
        PasswordIterator { generator: Box::new(self), rng: rng }
    }

    fn or<'a, T>(self, other: T) -> Switch<'a>
        where
            Self: Sized + 'a,
            T: PasswordGenerator + Sized + 'a
    {
        let generators: Vec<Box<dyn PasswordGenerator>> =
            vec![Box::new(other), Box::new(self)];

        Switch { generators }
    }
}

/// A `PasswordGenerator` that is composed on the pipelined
/// sequence of two `PasswordGenerator` objects.
pub struct ChainedGenerator<'a> {
    first: Box<dyn PasswordGenerator + 'a>,
    second: Box<dyn PasswordGenerator + 'a>,
}

impl<'a> PasswordGenerator for ChainedGenerator<'a> {
    fn generate_with_seed(&self, rng: &mut ThreadRng, seed: String) -> String {
        let seed = self.first.generate_with_seed(rng, seed);
        self.second.generate_with_seed(rng, seed)
    }
}

/// A `PasswordGenerator` that simply generates a constant password.
pub struct Constant { value: String }

impl Constant {
    pub fn new(seed: &str) -> Constant {
        let value = String::from_str(&seed).unwrap();
        Constant { value }
    }
}

impl PasswordGenerator for Constant {
    fn generate_with_seed(&self, _rng: &mut ThreadRng, seed: String) -> String {
        seed + &self.value
    }
}

/// An `Iterator` that allows for iterating over random passwords generated by
/// a `PasswordGenerator`.
pub struct PasswordIterator<'a> {
    generator: Box<dyn PasswordGenerator + 'a>,
    rng: ThreadRng
}

impl<'a> Iterator for PasswordIterator<'a> {
    type Item = String;

    fn next(&mut self) -> Option<Self::Item> {
        let password = self.generator.generate_with_seed(&mut self.rng, String::new());
        Some(password)
    }
}

pub struct Switch<'a> {
    generators: Vec<Box<dyn PasswordGenerator + 'a>>,
}

impl<'a> PasswordGenerator for Switch<'a> {
    fn generate_with_seed(&self, rng: &mut ThreadRng, seed: String) -> String {
        let selection = rng.choose(&self.generators).unwrap();
        selection.generate_with_seed(rng, seed)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_constant_new() {
        let value = "test input";
        let passwords = Constant::new(value);
        assert_eq!(passwords.value, value);
    }

    #[test]
    fn test_constant_generate() {
        let value = "test input".to_string();
        let passwords = Constant { value };
        assert_eq!(passwords.generate(), passwords.value);
    }

    #[test]
    fn test_constant_generate_with_seed() {
        let value = " and more".to_string();
        let passwords = Constant { value };
        let mut rng = rand::thread_rng();
        let seed = "test input".to_string();
        assert_eq!(passwords.generate_with_seed(&mut rng, seed), "test input and more");
    }

    #[test]
    fn test_constant_iterator() {
        let value = "test input".to_string();
        let passwords = Constant { value };
        let mut iter = passwords.iterator().into_iter();
        assert_eq!(iter.next(), Some("test input".to_string()));
        assert_eq!(iter.next(), Some("test input".to_string()));
    }

    #[test]
    fn test_constant_pipe() {
        let passwords = Constant::new("test input")
            .pipe(Constant::new(" and more"));

        assert_eq!(passwords.generate(), "test input and more");
    }
}
